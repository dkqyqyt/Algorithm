# 17136번 색종이 붙이기

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞은 사람 | 정답 비율 |
| :-------- | :---------- | :--- | :--- | :-------- | :-------- |
| 1 초      | 512 MB      | 8903 | 3099 | 1528      | 31.408%   |

## 문제

<그림 1>과 같이 정사각형 모양을 한 다섯 종류의 색종이가 있다. 색종이의 크기는 1×1, 2×2, 3×3, 4×4, 5×5로 총 다섯 종류가 있으며, 각 종류의 색종이는 5개씩 가지고 있다.

![img](https://upload.acmicpc.net/496452ae-ce36-4d77-93f7-19d7f3f9ce28/-/preview/)

<그림 1>

색종이를 크기가 10×10인 종이 위에 붙이려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 0 또는 1이 적혀 있다. 1이 적힌 칸은 모두 색종이로 덮여져야 한다. 색종이를 붙일 때는 종이의 경계 밖으로 나가서는 안되고, 겹쳐도 안 된다. 또, 칸의 경계와 일치하게 붙여야 한다. 0이 적힌 칸에는 색종이가 있으면 안 된다.

종이가 주어졌을 때, 1이 적힌 모든 칸을 붙이는데 필요한 색종이의 최소 개수를 구해보자.

## 입력

총 10개의 줄에 종이의 각 칸에 적힌 수가 주어진다.

## 출력

모든 1을 덮는데 필요한 색종이의 최소 개수를 출력한다. 1을 모두 덮는 것이 불가능한 경우에는 -1을 출력한다.

## 예제 입력 1 

```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

## 예제 출력 1 

```
0
```

## 예제 입력 2 

```
0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

## 예제 출력 2 

```
4
```

## 예제 입력 3 

```
0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

## 예제 출력 3 

```
5
```

## 예제 입력 4 

```
0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

## 예제 출력 4 

```
-1
```

## 예제 입력 5 

```
0 0 0 0 0 0 0 0 0 0
0 1 1 0 0 0 0 0 0 0
0 1 1 1 0 0 0 0 0 0
0 0 1 1 1 1 1 0 0 0
0 0 0 1 1 1 1 0 0 0
0 0 0 0 1 1 1 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

## 예제 출력 5 

```
7
```

## 예제 입력 6 

```
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
```

## 예제 출력 6 

```
4
```

## 예제 입력 7 

```
0 0 0 0 0 0 0 0 0 0
0 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 0 0 0 0
0 0 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 1
0 1 1 1 0 1 1 1 1 1
0 1 1 1 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
0 0 0 0 0 1 1 1 1 1
```

## 예제 출력 7 

```
6
```

## 예제 입력 8 

```
0 0 0 0 0 0 0 0 0 0
1 1 1 1 1 0 0 0 0 0
1 1 1 1 1 0 1 1 1 1
1 1 1 1 1 0 1 1 1 1
1 1 1 1 1 0 1 1 1 1
1 1 1 1 1 0 1 1 1 1
0 0 0 0 0 0 0 0 0 0
0 1 1 1 0 1 1 0 0 0
0 1 1 1 0 1 1 0 0 0
0 1 1 1 0 0 0 0 0 1
```

## 예제 출력 8 

```
5
```

## 나의 코드

백트래킹 말고는 풀 수 있는 방법이 마땅히 떠오르지가 않는다.

각 점마다 다섯 개의 크기의 색종이를 놓을 수 있는 자린지 아닌지를 파악하는 함수를 하나 만든다. 재귀의 깊이를 점점 늘려가면서 1이 쓰여져 있는 점으로 넘어가서 모두 채웠을 때 쓰인 색종이의 수를 비교한다.

```
import sys

graph = []

loc = []
for i in range(10):
    tmp = list(map(int,input().split()))
    for j in range(len(tmp)):
        if tmp[j] == 1:
            loc.append((i,j))
    graph.append(tmp)

if len(loc) == 0:
    print(0)
    sys.exit(0)
visit = [[0 for _ in range(10)] for _ in range(10)]
paper = [5]*5
min_use = 987654321
def canMake(x,y,wide):
    if x+wide-1 >= 10 or y+wide-1 >=10:
        return False
    for i in range(wide):
        for j in range(wide):
            if graph[x+i][y+j] == 0:
                return False
            if visit[x+i][y+j]:
                return False
    return True

def track(use,idx):
    global min_use

    if use >= min_use:
        return
    if idx == len(loc):
        if use < min_use:
            min_use = use
        return

    x = loc[idx][0]
    y = loc[idx][1]
    if visit[x][y]:
        track(use,idx+1)
    else:
        for w in range(5,1,-1):
            if paper[w-1] <= 0:
                continue
            if canMake(x,y,w):
                for i in range(w):
                    for j in range(w):
                        visit[x+i][y+j] = 1
                paper[w-1] -= 1
                track(use+1,idx+1)
                for i in range(w):
                    for j in range(w):
                        visit[x+i][y+j] = 0
                paper[w-1] += 1

        if paper[0] > 0:
            visit[x][y] = 1
            paper[0] -= 1
            track(use+1,idx+1)
            visit[x][y] = 0
            paper[0] += 1

track(0,0)

if min_use == 987654321:
    print(-1)
else:
    print(min_use)
```

